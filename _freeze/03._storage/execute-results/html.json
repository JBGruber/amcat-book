{
  "hash": "0a9ab79272ed0e3fd10020d1a0e0dda9",
  "result": {
    "markdown": "---\ntitle: \"Document Storage\"\nexecute:\n  freeze: true\nbibliography: references.bib\n---\n\n\n\n\n\n::: {.callout-note}\nThe minimum modules you need to work with document storage:\n\n![amcat instance after following this chapter](media/amcat-flow-getting-started.drawio.png)\n\nYou need either the [R](#amcat4r) or [Python](#amcat4apiclient) package, not both.\n:::\n\n## Fill your database\n\n::: {.callout-important}\n# Will change soon\n\nCurrently, there is no way to add data through the web interface.\nRather, you can add new datasets through calls to the amcat API.\n:::\n\nYou can upload document to the amcat server by using our [`R` package](#manage-storage-using-r), [`Python` package](#manage-storage-using-python) or calling the [API directly](#manage-storage-using-api-calls).\nOf course, you can use the calls in the [API section]() and write an API wrapper in another language of your choice.\nLet us know about it and we will promote your package here.\n\n### Manage storage using `R`\n\nTo manage data from `R`, we provide several functions in the `amcat4r` package.\nFor this overview, I log into a local `amcat4` (i.e., `http://localhost/api`).\nReplace this with the address to the `amcat4` instance you are working with (e.g., `https://opted.amcat.nl/api`).\n\nWe first need to log in:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(amcat4r)\nlogin(\"http://localhost/api\",  username = \"admin\", password = \"supergeheim\")\n```\n:::\n\n\nIf you are using RStudio, you can omit the `password` argument and enter it instead through the RStudio password dialogue.\n\nWe can first list all available indexes, as a document collection is called in Elasticsearch and thus in amcat:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist_indexes()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 2\n  name               role \n  <chr>              <chr>\n1 state_of_the_union ADMIN\n```\n:::\n:::\n\n\nYou can see that the test index we added in the [Data Layer](#data-layer) section is here and that it is called \"state_of_the_union\".\nWe can see who has access to this index: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist_index_users(index = \"state_of_the_union\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 2\n  email role \n  <chr> <chr>\n1 admin ADMIN\n```\n:::\n:::\n\n\nTo see what an index looks like, we can query it leaving all fields blank to request all data at once:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsotu <- query_documents(index = \"state_of_the_union\", fields = NULL)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRetrieved 232 results in 1 pages\n```\n:::\n\n```{.r .cell-code}\nstr(sotu)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntibble [232 × 7] (S3: tbl_df/tbl/data.frame)\n $ .id      : chr [1:232] \"3411a08d219f601be3a6596196436b64d0c9fe27967ae6118c7d1c50\" \"56593148b47cc7027a964fcabb22bb13fda1bcbd5cc50fa333876ae6\" \"ca3069f6ec7ad5fb1fe1a0c3d1c08e40f38075d7eb660550b320b190\" \"8b24279714759f8efd2193cbf8d84324aac01e52ad3b4ab2143de4e9\" ...\n $ title    : chr [1:232] \"1790: George Washington\" \"1790: George Washington\" \"1791: George Washington\" \"1792: George Washington\" ...\n $ text     : chr [1:232] \"Fellow-Citizens of the Senate and House of Representatives:  \\nI embrace with great satisfaction the opportunit\"| __truncated__ \"Fellow-Citizens of the Senate and House of Representatives:  \\nIn meeting you again I feel much satisfaction in\"| __truncated__ \"Fellow-Citizens of the Senate and House of Representatives:  \\n\\\"In vain may we expect peace with the Indians o\"| __truncated__ \"Fellow-Citizens of the Senate and House of Representatives:  \\nIt is some abatement of the satisfaction with wh\"| __truncated__ ...\n $ date     : POSIXct[1:232], format: \"1790-01-08\" \"1790-12-08\" ...\n $ president: chr [1:232] \"George Washington\" \"George Washington\" \"George Washington\" \"George Washington\" ...\n $ year     : chr [1:232] \"1790\" \"1790\" \"1791\" \"1792\" ...\n $ party    : chr [1:232] \"N/A\" \"N/A\" \"N/A\" \"N/A\" ...\n```\n:::\n:::\n\n\nKnowing now what a document should look like in this index, we can upload a new document to get familiar with the process:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_doc <- data.frame(\n  title = \"test\",\n  text = \"test\",\n  date = as.Date(\"2022-01-01\"),\n  president = \"test\",\n  year = 2022L,\n  party = \"test\",\n  url = \"test\"\n)\nupload_documents(index = \"state_of_the_union\", new_doc)\n```\n:::\n\n\n\n\nLet's see if the the new document is in the index:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquery_documents(index = \"state_of_the_union\", fields = NULL, filters = list(title = \"test\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRetrieved 1 results in 1 pages\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 8\n  .id                  title date                text  url   party presi…¹  year\n  <chr>                <chr> <dttm>              <chr> <chr> <chr> <chr>   <int>\n1 47e0f77cba833d26c96… test  2022-01-01 00:00:00 test  test  test  test     2022\n# … with abbreviated variable name ¹​president\n```\n:::\n:::\n\n\nWe will learn more about queries later on in the [Writing a Query]() chapter.\nFor now, you can look at the documentation using `?query_documents`.\n\nInstead of adding whole documents, you can also change fields in an index.\nFields are similar to columns in an `R` data frame.\nHowever, you need to define the type of a field upon its creation and make sure that you later only add data which adheres to the specifications of the type.\nTo learn more about the fields in the test index, you can use:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_fields(index = \"state_of_the_union\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 × 2\n  name      type   \n  <chr>     <chr>  \n1 date      date   \n2 party     keyword\n3 president keyword\n4 text      text   \n5 title     text   \n6 url       url    \n7 year      double \n```\n:::\n:::\n\n\nYou can see that there are five different types in this index: date, keyword, text, url and double.\nKeyword, text, url are all essentially the same type in `R`, namely character strings.\nThe date needs to be a `POSIXct` class, which you can create with `as.Date`.\nYear should be a double, i.e., a numeric value or integer.\n\nYou can add new fields to this, for example, if you want to add a keyword to the documents:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset_fields(index = \"state_of_the_union\", list(keyword = \"keyword\"))\n```\n:::\n\n\nWhen you now query a document, however, you will not see this new field:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquery_documents(index = \"state_of_the_union\", fields = NULL, filters = list(title = \"test\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRetrieved 1 results in 1 pages\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 8\n  .id                  title date                text  url   party presi…¹  year\n  <chr>                <chr> <dttm>              <chr> <chr> <chr> <chr>   <int>\n1 47e0f77cba833d26c96… test  2022-01-01 00:00:00 test  test  test  test     2022\n# … with abbreviated variable name ¹​president\n```\n:::\n:::\n\n\nThis is because it is empty for this document, just as the url field, which is absent from all documents in this index.\nWe can add something to the new field and see if it shows up:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nupdate_tags(index = \"state_of_the_union\", action = \"add\", field = \"keyword\", tag = \"test\", filters = list(title = \"test\"))\nquery_documents(index = \"state_of_the_union\", fields = c(\"title\", \"keyword\"), filters = list(title = \"test\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRetrieved 1 results in 1 pages\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 2\n  .id                                                      title\n  <chr>                                                    <chr>\n1 47e0f77cba833d26c963c3a3370e8dad8416cf55c0612c96e241aa12 test \n```\n:::\n:::\n\n\nNow that we have a better idea of what an index is and how it looks like, we can create a new one>\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreate_index(index = \"new_index\", guest_role = \"admin\")\nlist_indexes()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 2\n  name               role \n  <chr>              <chr>\n1 state_of_the_union ADMIN\n2 new_index          ADMIN\n```\n:::\n\n```{.r .cell-code}\nget_fields(index = \"new_index\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 2\n  name  type \n  <chr> <chr>\n1 date  date \n2 text  text \n3 title text \n4 url   url  \n```\n:::\n:::\n\n\nAs you can see, the newly created index already contains fields.\nYou could now manually define new fields to fit your data.\nOr you can simply start uploading data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_doc <- data.frame(\n  title = \"test\",\n  text = \"test\",\n  date = as.Date(\"2022-01-01\"),\n  president = \"test\",\n  year = 2022,\n  party = \"test\",\n  url = \"test\"\n)\nupload_documents(index = \"new_index\", new_doc)\nget_fields(index = \"new_index\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 × 2\n  name      type \n  <chr>     <chr>\n1 date      date \n2 party     text \n3 president text \n4 text      text \n5 title     text \n6 url       url  \n7 year      long \n```\n:::\n:::\n\n\namcat4 guesses the types of fields based on the data.\nYou can see here that this might not be the best option if you care about data types: party and president have been created as text, when they should be keywords; year is now a long type instead of double or integer. \n<!-- TODO: Why should people care about types? -->\n\nFinally, we can also delete an index:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndelete_index(index = \"new_index\")\n```\n:::\n\n\n\n### Manage storage using `Python`\n\n::: {.callout-important}\n# Coming soon...\n:::\n\n### Manage storage using API calls\n\n::: {.callout-important}\n# Coming soon...\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}